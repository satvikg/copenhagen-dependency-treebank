#summary The DTAG query language

= Introduction =

DTAG has a rich query language based on first-order logic. This page describes the detailed syntax of the query language, provides examples of queries that can be performed with DTAG, and briefly describes how the query system works internally. 

<wiki:toc max_depth="3"/>

= Query language syntax =

== Relation constraints ==

  * *{{{<node1> <relation-constraint> <node2>}}}*: the first node is connected to the second via an in-edge whose relation name matches the given relation constraint. 

The relation constraint can be of the form:
  * *{{{<string>}}}*: an unquoted atomic relation name.
  * *{{{"<string>"}}}*: a quoted atomic relation name.
  * *{{{/<regexp>/}}}*: a [http://perldoc.perl.org/perlre.html regular expression in Perl].
  * *{{{isa(<super>)}}}*: an isa-constraint that matches relations that are either subrelations of the super relation {{{<super>}}}, or equal to the super relation itself,  in the relation hierarchy.

Examples include:

  * {{{$X "subj" $Y}}}: find all edges into $X from $Y with atomic label "subj".
  * {{{$X coref $Y}}}: find all edges into $X from $Y with atomic label "coref".
  * {{{$X /obj/ $Y}}}: find all edges into $X from $Y whose name contains "obj".
  * {{{$X /^(subj|dobj)$/ $Y}}}: find all edges into $X from $Y whose name matches either "subj" or "dobj".
  * {{{$X isa(SYNADJ) $Y}}}: find all syntactic adjunct edges into $X from $Y. 

== Comparison operators ==

Values can be given as atomic values (numbers or strings enclosed in double quotes), or as nodes or node features:

   * *{{{"<string>"}}}*: the given string as an atomic string value (eg '"hello world!"').
   * *{{{<number>}}}*: the given number as an atomic number value (eg '123', '-13.3').
   * *{{{<node>}}}*: the node number as a numerical value (eg, '$X').
   * *{{{<node>[]}}}*: the string associated with the node (eg, '$NODE[]').
   * *{{{<node>[<attribute>]}}}*: the string or number associated with the given feature in the given node (eg, '$X[msd]'). The interpretation as string or number depends on the operator that is applied to the value. 

String values can be compared with the following operators:

  * *{{{<value1> eq <value2>}}}*: the two values are equal as strings, eg:
      * {{{$X[lemma] eq "they"}}}: find all nodes where the lemma attribute equals "they". 
      * {{{$X[] eq "They"}}}: find all nodes where the input string equals "They".
  * *{{{<value> =~ /<regexp>/}}}*: the string value matches the given regular expression, eg:
      * {{{$X[lemma] =~ /ics$/}}}: find all nodes where the lemma attribute ends with "ics".
  * *{{{<value> !~ /<regexp>/}}}*: the string value does not match the given regular expression.

Numerical values can be compared with the following operators:
  * *{{{<value1> < <value2>}}}*: the first value is numerically smaller than the second.
  * *{{{<value1> <= <value2>}}}*: the first value is numerically smaller than or equal to the second.
  * *{{{<value1> = <value2>}}}*: the first value is numerically equal to the second.
  * *{{{<value1> > <value2>}}}*: the first value is numerically larger than the second.
  * *{{{<value1> >= <value2>}}}*: the first value is numerically larger than or equal to the second.
For example:
  * {{{$X < $Y}}}: the first node precedes the second in the linear order.
  * {{{$X > $Y}}}: the first node succeeds the second in the linear order.
  * {{{$X[time] > 20.7}}}: the time attribute associated with $X must be at least 20.7.

== Complex queries ==

It is advisable to enclose simple queries in parentheses "(...)" when joining them with logical operators.

  * *{{{<cond1> & <cond2>}}}*: satisfied by both conditions.
  * *{{{<cond1> | <cond2>}}}*: satisfied by at least one of the conditions.
  * *{{{! <cond>}}}*: satisfied if condition fails.

= Example queries =

= Find and replace =

   * *{{{etypes(<relation>)}}}*: the "|"-concatenated alphabetically sorted list of relation types for all edges that match the given relation (eg, {{{etypes($X isa(PRIM) $Y}}}). 

= Working with corpora =

= Querying multi-file graphs =